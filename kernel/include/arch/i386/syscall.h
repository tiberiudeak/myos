#ifndef KERNEL_SYSCALL_H
#define KERNEL_SYSCALL_H 1

#include <stdio.h>
#include <arch/i386/pit.h>
#include <mm/kmalloc.h>
#include <fs.h>

#define MAX_SYSCALLS	4

/**
 * Test syscall
 */
void syscall_test0(void) {
	printf("Syscall test 0 works\n");
}

/**
 * Test syscall
 */
void syscall_test1(void) {
	printf("Syscall test 1 works\n");
}

/**
 * @brief Sleep syscall
 *
 * This function reads the number of milliseconds to wait from EBX and
 * calls wait_millis.
 */
void syscall_sleep(void) {
	uint16_t millis = 0;

	__asm__ __volatile__ ("movl %%ebx, %%ecx" : "=c"(millis) : );

	wait_millis(millis);
}

/**
 * @brief Open syscall
 *
 * the filepath will be in EBX
 * the flags will be in ECX
 */
void syscall_open(void) {
    int32_t fd = -1;
    char *path = 0;
    uint32_t flags = 0;

    // data from kernel
    extern open_files_table_t *open_files_table;
    extern inode_block_t *open_inodes_table;
    extern uint8_t current_open_fd;
    extern uint8_t current_open_inode_idx;

    __asm__ __volatile__ ("mov %%ebx, %0\n"
                          "mov %%ecx, %1" : "=b"(path), "=c"(flags));

    // get file inode
    inode_block_t inode = get_inode_from_path(path);

    // file doesn't exist
    // TODO: check for O_CREAT flag
    if (inode.id == 0) {
        goto err;
    }

    // search for the inode in the open inodes table
    inode_block_t *tmp = open_inodes_table;
    uint32_t tmp_idx = current_open_inode_idx;
    int32_t free_idx = -1;

    // skip first three entries (reserved for fd 0, 1 and 2)
    tmp += 3;

    while (tmp->id != inode.id && tmp_idx < MAX_OPEN_FILES) {
        
        // store first free place in the table
        if (tmp->id == 0) {
            free_idx = tmp_idx;
        }
        tmp_idx++;
        tmp++;
    }


    if (tmp->id == inode.id) {
        // inode found, increase ref count
        tmp->reference_number++;
    }
    else {
        // add inode in table
        if (free_idx != -1) {
            *(open_inodes_table + free_idx) = inode;
        }
        else {
            // max open inodes reached, error
            printf("limit of open files reached: %d! close some to open more!\n", MAX_OPEN_FILES);
            goto err;
        }
    }

    // add to open files table
    open_files_table_t *tmp_oft = open_files_table;
    tmp_idx = current_open_fd;

    // skip first three entries in the table (stdin, stdout and stderr)
    tmp_oft += 3;

    // search for an empty place for the file
    while (tmp_idx < MAX_OPEN_FILES && tmp_oft->address != 0) {
        tmp_idx++;
        tmp_oft++;
    }

    if (tmp_idx == MAX_OPEN_FILES) {
        printf("limit of open files reached: %d! close some to open more!\n", MAX_OPEN_FILES);
        goto err;
    }

    // add new open_files_table_t entry at the found free position and return the position

    // allocate memory for the inode (as the inode is a local variable here)
    void *addr = kmalloc(sizeof(inode_block_t));

    if (addr == NULL) {
        printf("out of memory\n");
        goto err;
    }

    *(inode_block_t*)addr = inode;

    tmp_oft->inode = addr;
    tmp_oft->reference_number = 0;
    tmp_oft->offset = 0;
    tmp_oft->flags = 0;

    // allocate memory for the file's data
    uint32_t needed_bytes = bytes_to_blocks(inode.size_bytes) * FS_BLOCK_SIZE;

    addr = kmalloc(needed_bytes);

    if (addr == NULL) {
        printf("out of memory\n");
        goto err;
    }

    int ret = load_file(&inode, (uint32_t)addr);

    if (ret) {
        printf("error loading block from disk\n");
        goto err;
    }

    tmp_oft->address = addr;

    // put index in the open files table into EAX and return
    __asm__ __volatile__ ("mov %%ebx, %%eax" : : "b"(tmp_idx));
    return;

err:
    __asm__ __volatile__ ("mov $-1, %eax");
    return;
}

//void syscall_kmalloc(void) {
//    uint32_t size_bytes;
//
//    // get size in bytes from EBX
//    __asm__ __volatile__ ("mov %%ebx, %0" : "=r"(size_bytes));
//
//}

//void syscall_kfree(void) {
//    printf("kernel free called");
//    uint32_t addr = 0;
//
//    //get address from EBX
//    __asm__ __volatile__ ("mov %%ebx, %0" : "=r"(addr));
//
//    printf("%x\n", addr);
//}

void *syscalls[MAX_SYSCALLS] = {
	syscall_test0,
	syscall_test1,
	syscall_sleep,
    syscall_open
};

/**
 * @brief Syscall interrupt handler
 *
 * This is the interrupt handler for a syscall (int $0x80). Pushes
 * registers to stack, calls the syscall function in the syscall functions
 * array (with %eax * 4 as the offset), pops registers back and then returns
 * using the "iret" instruction (return from interrupt).
 *
 * __attribute__ ((naked)) means that the function doesn't need prologue/
 * epilogue sequences generated by the compiler and the only statements that
 * can be safely included are asm statements that do not have operands.
 */
__attribute__ ((naked)) void syscall_handler(void) {
	__asm__ __volatile__ ("cmp $4, %eax\n"	// check if syscall exists
											// number has to match MAX_SYSCALLS!
	"jge syscall_invalid\n"					// if not, invalid syscall
	"push %eax\n"
	"push %gs\n"
	"push %fs\n"
	"push %es\n"
	"push %ds\n"
	"push %edi\n"
	"push %esi\n"
	"push %edx\n"
	"push %ecx\n"
	"push %ebx\n"
	"push %esp\n"
	"movl $4, %edx\n"				// move value 4 in ebx
	"mul %edx\n"					// eax = eax * ebx
	"add $syscalls, %eax\n"			// add offset in eax to the beginning of the
	"call *(%eax)\n"				// syscalls array to get the right syscall
	"add $4, %esp\n"
	"pop %ebx\n"
	"pop %ecx\n"
	"pop %edx\n"
	"pop %esi\n"
	"pop %edi\n"
	"pop %ds\n"
	"pop %es\n"
	"pop %fs\n"
	"pop %gs\n"
	"add $4, %esp\n"
	"syscall_invalid:\n"
	"iret");
}

#endif /* !KERNEL_SYSCALL_H */
