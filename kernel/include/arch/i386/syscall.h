#ifndef KERNEL_SYSCALL_H
#define KERNEL_SYSCALL_H 1

#include <stdio.h>
#include <arch/i386/pit.h>

#define MAX_SYSCALLS	3

/**
 * Test syscall
 */
void syscall_test0(void) {
	printf("Syscall test 0 works\n");
}

/**
 * Test syscall
 */
void syscall_test1(void) {
	printf("Syscall test 1 works\n");
}

/**
 * @brief Sleep syscall
 *
 * This function reads the number of milliseconds to wait from EBX and
 * calls wait_millis.
 */
void syscall_sleep(void) {
	uint16_t millis = 0;

	__asm__ __volatile__ ("movl %%ebx, %%ecx" : "=c"(millis) : );

	wait_millis(millis);
}

//void syscall_kmalloc(void) {
//    uint32_t size_bytes;
//
//    // get size in bytes from EBX
//    __asm__ __volatile__ ("mov %%ebx, %0" : "=r"(size_bytes));
//
//}

//void syscall_kfree(void) {
//    printf("kernel free called");
//    uint32_t addr = 0;
//
//    //get address from EBX
//    __asm__ __volatile__ ("mov %%ebx, %0" : "=r"(addr));
//
//    printf("%x\n", addr);
//}

void *syscalls[MAX_SYSCALLS] = {
	syscall_test0,
	syscall_test1,
	syscall_sleep
};

/**
 * @brief Syscall interrupt handler
 *
 * This is the interrupt handler for a syscall (int $0x80). Pushes
 * registers to stack, calls the syscall function in the syscall functions
 * array (with %eax * 4 as the offset), pops registers back and then returns
 * using the "iret" instruction (return from interrupt).
 *
 * __attribute__ ((naked)) means that the function doesn't need prologue/
 * epilogue sequences generated by the compiler and the only statements that
 * can be safely included are asm statements that do not have operands.
 */
__attribute__ ((naked)) void syscall_handler(void) {
	__asm__ __volatile__ ("cmp $3, %eax\n"	// check if syscall exists
											// number has to match MAX_SYSCALLS!
	"jge syscall_invalid\n"					// if not, invalid syscall
	"push %eax\n"
	"push %gs\n"
	"push %fs\n"
	"push %es\n"
	"push %ds\n"
	"push %edi\n"
	"push %esi\n"
	"push %edx\n"
	"push %ecx\n"
	"push %ebx\n"
	"push %esp\n"
	"movl $4, %edx\n"				// move value 4 in ebx
	"mul %edx\n"					// eax = eax * ebx
	"add $syscalls, %eax\n"			// add offset in eax to the beginning of the
	"call *(%eax)\n"				// syscalls array to get the right syscall
	"add $4, %esp\n"
	"pop %ebx\n"
	"pop %ecx\n"
	"pop %edx\n"
	"pop %esi\n"
	"pop %edi\n"
	"pop %ds\n"
	"pop %es\n"
	"pop %fs\n"
	"pop %gs\n"
	"add $4, %esp\n"
	"syscall_invalid:\n"
	"iret");
}

#endif /* !KERNEL_SYSCALL_H */
